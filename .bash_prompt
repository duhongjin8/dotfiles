# enable git unstaged indicators - set to a non-empty value
GIT_PS1_SHOWDIRTYSTATE="."

# enable showing of untracked files - set to a non-empty value
GIT_PS1_SHOWUNTRACKEDFILES="."

# enable stash checking - set to a non-empty value
GIT_PS1_SHOWSTASHSTATE="."

# enable showing of HEAD vs its upstream
GIT_PS1_SHOWUPSTREAM="auto"

BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
LIME_YELLOW=$(tput setaf 190)
POWDER_BLUE=$(tput setaf 153)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
BRIGHT=$(tput bold)
NORMAL=$(tput sgr0)
BLINK=$(tput blink)
REVERSE=$(tput smso)
UNDERLINE=$(tput smul)

# set the prompt to show current working directory and git branch name, if it exists

# this prompt is a green username, black @ symbol, cyan host, magenta current working directory and white git branch (only shows if you're in a git branch)
# unstaged and untracked symbols are shown, too (see above)
# this prompt uses the short colour codes defined above
# PS1='${GREEN}\u${BLACK}@${CYAN}\h:${MAGENTA}\w${WHITE}`__git_ps1 " (%s)"`\$ '

# this is a cyan username, @ symbol and host, magenta current working directory and white git branch
# it uses the shorter , but visibly more complex, codes for text colours (shorter because the colour code definitions aren't needed)
 #PS1='\[\033[0;36m\]\u@\h\[\033[01m\]:\[\033[0;35m\]\w\[\033[00m\]\[\033[1;30m\]\[\033[0;37m\]`__git_ps1 " (%s)"`\[\033[00m\]\[\033[0;37m\]\$ '
 #PS1='\[\033[0;36m\]â–¤ \[\033[0;35m\]\w\[\033[00m\]\[\033[1;30m\]\[\033[0;37m\]`__git_ps1 " (%s)"`\[\033[00m\]\[\033[0;37m\]\$ '
 PS1='\[\e[1;32m\]\w\[\e[0m\]\[\033[0;36m\]`__git_ps1 " (%s)"` \[\e[0m\]'
#PS1='\[\033[0;36m\]\u`__git_ps1`\[\033[01m\]:\[\033[0;35m\]\w\[\033[00m\]\[\033[1;30m\]\[\033[0;37m\]\[\033[00m\]\[\033[0;37m\]\$ '

#parse_git_branch() {
  #git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
#}
if [ -f ~/.git-completion.bash ]; then
  . ~/.git-completion.bash
fi

#PS1="\[$GREEN\]\t\[$RED\]-\[$BLUE\]\u\[$YELLOW\]\[$YELLOW\]\w\[\033[m\]\[$MAGENTA\]\$(__git_ps1)\[$WHITE\]\$ "

# return the prompt prefix for the second line
#function set_prefix {
    #BRANCH=`parse_git_branch`
    #if [[ -z $BRANCH ]]; then
        #echo "${NORMAL}o"
    #else
        #echo "${UNDERLINE}+"
    #fi
#}

# and here's one similar to Paul Irish's famous prompt ... not sure if this is the way he does it, but it works  :)
# \033[s = save cursor position
# \033[u = restore cursor position

#export PS1='${MAGENTA}\u${WHITE} in ${GREEN}\w${WHITE}${MAGENTA}`parse_git_branch " on %s"`${WHITE}\r\n`set_prefix`${NORMAL}${CYAN}\033[s\033[60C (`date "+%a, %b %d"`)\033[u${WHITE} '

# export PS1='${MAGENTA}\u${WHITE} in ${GREEN}\w${WHITE}${WHITE}`parse_git_branch " on %s"`${WHITE}\r\n`set_prefix`${NORMAL}${CYAN}\033[s\033[60C \033[u${WHITE} '

#export PS1=" \[\033[32m\]\w\[\033[0m\]`parse_git_branch`\n\[\033[1;36m\]\u\[\033[1;33m\]-> \[\033[0m\]"
#export PS1="\n[\[\033[32m\]\\u \w\[\033[0m\]]${MAGENTA}`parse_git_branch`\n${BRIGHT}`set_prefix`${NORMAL} "
#export PS1="\n[\[\033[32m\]\w\[\033[0m\]]${MAGENTA}`parse_git_branch`\n${BRIGHT}`set_prefix`${NORMAL} "

